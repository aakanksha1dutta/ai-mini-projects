Group members: Aakanksha Dutta (adutta5@u) and Aabha Pandit (apandit@u)


The goal of this project is to solve a sliding block puzzle, given an input of a n*n matrix and search algorithm. 
Our project implements the BFS and A* search algorithms.


The Manhattan heuristic was used for the A* implementation. It calculates the distance between the current 
position of each digit on the current state and its goal state position. The distance is calculated as the 
absolute difference in the x-coordinate and the y-coordinate of the current and goal positions. 
These distances are then summed up for all digits of the board, which gives us the heuristic value. It is 
also consistent because movement is confined to vertical or horizontal moves so the manhattan heuristic will
drop by at most 1 unit, which is also the cost from one state to another. 
h(n) - h(n') <= c(n,n',a)
h(n) <= c(n,n',a) + h(n') 
Therefore, manhattan heuristic is consistent and hence, it is also admissible. 

For puzzles with less moves, both BFS and A* had similar runtime performances. However, for puzzle with more moves
(like /u/cs242/hw2/test14_in) A* was almost instantneous where BFS takes much longer (around 1 minute and 30 sec). 
For the /u/cs242/hw2/test14_in, BFS expanded through 6330 nodes while A* expanded only 54 nodes. 

The following is a summary of each class and its function:
puzzle.py:
    This class contains the main method which reads in the input, appropriately formats it and calls the 
    state and game classses to find a solution. The path of moves taken to achieve solution is then printed.

game.py:
    This class is the actual puzzle solver. It initializes the puzzle with an initial 
    state, the size of the puzzle (n), and a goal state. The resulting states are generated by applying a 
    specific action to a give state (moving blank block up, down, left, right). Then, either BFS or A* is used
    to comb through the resulting states. 
    A* uses a priority queue where the priority of each state is determined by its cost, which includes the
    Manhattan heuristic value. It expands iteratively till goal state is reached.
    BFS uses the same priority queue structure except the cost of each state is determined jusy by its depth
    in the tree. It expands searching each level until the goal state is reached.
    
state.py: 
    This class represents a state in the puzzle solving algorithm. It includes methods for calculating cost 
    (using the Manhattan heuristic), retrieval of parent state and move information (to get to current state), 
    and custom comparators for the priority queue (frontier).

